package ru.zahaand.patterns.state;

/**
 * <h1>Паттерн State. Состояние</h1>
 * Интерфейс {@code UserState} является частью реализации паттерна State.
 * Он предоставляет способ изменения поведения объекта во время выполнения программы,
 * позволяя объекту менять свое состояние без необходимости изменения самого объекта.
 * Паттерн "Состояние" позволяет инкапсулировать различные состояния и логику перехода между ними внутри отдельных классов-состояний.
 *
 * <p>Паттерн State обеспечивает единый интерфейс для различных состояний,
 * позволяя клиентам работать с различными состояниями одинаково, используя один и тот же код.
 * Это упрощает добавление новых состояний и повышает удобство работы с объектами, меняющими свое состояние.
 *
 * <h3>Паттерн State обеспечивает следующие основные преимущества:</h3>
 * <ul>
 *     <li><strong>Инкапсуляция</strong>: Скрывает детали реализации состояния от клиента.</li>
 *     <li><strong>Гибкость</strong>: Позволяет легко добавлять новые состояния, не изменяя существующий код.</li>
 *     <li><strong>Читаемость</strong>: Улучшает читаемость кода за счет явного разделения логики различных состояний.</li>
 * </ul>
 *
 * <h3>Паттерн State целесообразно применять в следующих ситуациях:</h3>
 * <ul>
 *     <li><strong>Когда объект должен иметь различные состояния</strong>: Если объект может находиться в одном из нескольких состояний, и его поведение зависит от текущего состояния.</li>
 *     <li><strong>Когда необходимо избежать большого числа условий</strong>: Если логика объекта зависит от его состояния и приводит к сложным конструкциям условий, то применение паттерна "Состояние" может упростить структуру кода.</li>
 *     <li><strong>Когда необходимо обеспечить гибкость в изменении поведения объекта</strong>: Если требуется возможность динамически изменять поведение объекта во время выполнения программы.</li>
 * </ul>
 *
 * <h3>Пример использования:</h3>
 * <pre>
 *     User user = new User(new ActiveUserState());
 *     user.executeStateAction();   // Пользователь активен. Доступны все функции.
 *
 *     user.setState(new BlockedUserState());
 *     user.executeStateAction();   // Пользователь заблокирован. Доступ ограничен.
 * </pre>
 * <p>
 * В этом примере пользователь может находиться в одном из двух состояний: активном или заблокированном.
 * Изменение состояния пользователя приводит к изменению его поведения при вызове метода {@code executeStateAction()}.
 * Это демонстрирует, как паттерн "Состояние" позволяет динамически изменять поведение объекта во время выполнения программы.
 */
public interface UserState {

    /**
     * Выполняет действие, соответствующее текущему состоянию объекта.
     * В контексте паттерна State этот метод является ключевым, поскольку он позволяет объекту изменять свое поведение в зависимости от его внутреннего состояния.
     * Метод {@code executeStateAction} делегирует выполнение конкретного действия одному из объектов-состояний, которые реализуют интерфейс {@link UserState}.
     * Это обеспечивает гибкость и расширяемость, позволяя легко добавлять новые состояния без изменения существующего кода объекта, который использует эти состояния.
     *
     * <p>Использование метода {@code executeStateAction} позволяет инкапсулировать логику различных состояний в отдельных классах, что упрощает поддержку и развитие кода,
     * а также повышает его читаемость и понятность за счет явного разделения логики различных состояний.
     */
    void executeStateAction();
}
