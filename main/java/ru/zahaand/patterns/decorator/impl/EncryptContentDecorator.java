package ru.zahaand.patterns.decorator.impl;

import lombok.extern.slf4j.Slf4j;
import ru.zahaand.patterns.decorator.ContentDecorator;
import ru.zahaand.patterns.domain.Content;

/**
 * <h1>Паттерн Decorator. Декоратор</h1>
 * Класс {@code EncryptContentDecorator} представляет собой конкретный Decorator.
 * Добавляет функциональность шифрования к декорируемому объекту типа Content.
 * Оборачивает объект DisplayableContent и добавляет логику шифрования перед его отображением.
 *
 * <p>При вызове метода {@link #display()}, {@code EncryptContentDecorator} сначала выполняет операцию шифрования над контентом,
 * а затем делегирует вызов отображения контента декорируемому объекту. Это позволяет сохранить оригинальное поведение
 * отображения контента, добавив к нему дополнительную функциональность.
 *
 * <h3>Паттерн Decorator обеспечивает следующие ключевые преимущества:</h3>
 * <ul>
 *     <li><strong>Гибкость в расширении функциональности</strong>:
 *     Decorator позволяет динамически добавлять новые функции объектам, не изменяя их исходный код.
 *     Это достигается за счет оборачивания объектов в "декораторы", которые могут добавлять или изменять поведение.</li>
 *     <li><strong>Поддержка открытого/закрытого принципа</strong>:
 *     Паттерн Decorator поддерживает принцип OCP (Open/Closed Principle), позволяя расширять функциональность объектов
 *     без изменения их исходного кода. Это упрощает добавление новых возможностей и улучшений в будущем.</li>
 *     <li><strong>Улучшенная модульность</strong>:
 *     Использование декораторов повышает модульность системы, позволяя разделять ответственности между различными классами декораторов.
 *     Каждый декоратор может фокусироваться на одной задаче, что упрощает тестирование и поддержку кода.</li>
 *     <li><strong>Универсальность</strong>:
 *     Паттерн Decorator может быть применен к объектам различных типов,
 *     что делает его универсальным решением для расширения функциональности в различных контекстах.</li>
 * </ul>
 *
 * <h3>Паттерн Decorator целесообразно применять в следующих ситуациях:</h3>
 * <ul>
 *     <li><strong>Когда необходимо динамически изменять поведение объектов</strong>:
 *     Decorator позволяет добавлять новые функции к объектам во время выполнения,
 *     что делает систему гибкой и адаптивной к изменениям.</li>
 *     <li><strong>Для добавления функциональности без наследования</strong>:
 *     В случаях, когда наследование не является оптимальным решением из-за высокой связности или сложности иерархии классов,
 *     Decorator предлагает альтернативный способ расширения функциональности.</li>
 *     <li><strong>Когда требуется условное добавление функциональности</strong>:
 *     Decorator позволяет добавлять функции к объектам только тогда, когда это необходимо,
 *     что может быть полезно для оптимизации производительности и ресурсов.</li>
 *     <li><strong>Для обеспечения безопасности и конфиденциальности</strong>:
 *     Декораторы могут использоваться для добавления слоев защиты, таких как шифрование или проверка прав доступа,
 *     к объектам без изменения их первоначальной реализации.</li>
 * </ul>
 *
 * <h3>Пример использования:</h3>
 * <pre>
 *     Content textContent = new TextContent("Sample text", user);
 *     Content encryptedContent = new EncryptContentDecorator(textContent);
 *     encryptedContent.display();
 * </pre>
 * <p>
 * В этом примере создается объект TextContent, который затем оборачивается в EncryptContentDecorator.
 * При вызове метода display() на объекте encryptedContent сначала будет выполнена операция шифрования,
 * а затем отображен результат.
 */
@Slf4j
public class EncryptContentDecorator extends ContentDecorator {

    public EncryptContentDecorator(Content decoratedContent) {
        super(decoratedContent);
    }

    /**
     * Переопределенный метод.
     * Добавляет логику шифрования перед делегированием вызова отображения контента декорируемому объекту.
     */
    @Override
    public void display() {
        log.info("Encrypting content...");
        super.display();
    }
}
